= API-Sushi

== Objectif

Cette application Spring Boot Kotlin a pour finalité de mettre à disposition un service web de type API REST, au service d'applications frontend Angular réalisées par des étudiants en mode projet.

== Analyse de la structure JSON initiale

Nous partons d'une liste de _boxes_ initiale au format JSON.

L'objectif est de concevoir une API Rest qui produit ce résultat.

L'application Spring Boot doit donc structurer le domaine métier. Une analyse des données s'impose donc (recherche des dépendances, fonctionnelles et multivaluées réciproques, directes et élémentaires)

Une boxe a des propriétés simples, une liste de saveurs et une liste d'aliments.

Exemple d'une liste de boxes à 2 éléments (repr via plantuml)

.Structure JSON initiale
[plantuml]
----
@startjson
[
    {
        "id": 1,
        "nom": "Tasty Blend",
        "pieces": 12,
        "prix": 12.50,
        "image": "tasty-blend",
        "aliments": [
            {
                "nom": "California Saumon Avocat",
                "quantite": 3
            },
            {
                "nom": "Sushi Saumon",
                "quantite": 3
            },
            {
                "nom": "Spring Avocat Cheese",
                "quantite": 3
            },
            {
                "nom": "California pacific",
                "quantite": 3
            },
            {
                "nom": "Edamame/Salade de chou",
                "quantite": 1
            }
        ],
        "saveurs": [
            "saumon",
            "avocat",
            "cheese"
        ]
    },
    {
        "id": 2,
        "nom": "Amateur Mix",
        "pieces": 18,
        "aliments": [
            {
                "nom": "Maki Salmon Roll",
                "quantite": 3
            },
            {
                "nom": "Spring Saumon Avocat",
                "quantite": 3
            },
            {
                "nom": "Maki Cheese Avocat",
                "quantite": 6
            },
            {
                "nom": "California Saumon Avocat",
                "quantite": 3
            },
            {
                "nom": "Edamame/Salade de chou",
                "quantite": 1
            }
        ],
        "saveurs": [
            "coriandre",
            "saumon",
            "avocat",
            "cheese"
        ],
        "prix": 15.90,
        "image": "amateur-mix"
    }
]
@endjson
----
== Analyse conceptuelle

D'après la structure JSON fournie, nous pouvons en dégager les concepts suivants :

.Vue conceptuelle
[plantuml]
----
@startuml
class Box {
id
nom
nbPieces
prix
image
}

class Saveur {
id
nom
}

class Aliment {
id
nom
}

class AlimentBox {
  id
  quantite
}

Box "*" - "1..*" Saveur:"\t\t\t"
(Box, Aliment) . AlimentBox

hide circle
@enduml
----

== Analyse conceptuelle par réification de la classe association

Technique qui tend à uniformiser la représentation des entités.

*C'est ce schéma qui est retenu pour la représention du domaine.*

.Réification de la classe association
[plantuml]
----
@startuml
class Box {
id
nom
nbPieces
prix
image
}

class Saveur {
id
nom
}

class Aliment {
id
nom
}

class AlimentBox <<associacion>>{
  id
  quantite
}

Box "*" - "1..*" Saveur:"\t\t\t"
Box  "1" -- "*" AlimentBox:"\t\t\t\t"
AlimentBox  "*" - "1"  Aliment:"\t\t\t"

Note left of AlimentBox : Unique : (Box, Aliment)

hide circle
@enduml
----

TIP: La contrainte d'unicité permet de conserver le statut de _classe association_. Une simplicité gagnant-gagnant.

== Les images

En placant les images dans un sous-dossier (nommé images) du dossier `/resources/static`, on les rend accessibles directement.

Exemple : http://localhost:8080/images/tasty-blend.jpg

== Mapping Objet Relationnel

Le mapping se base sur <<_analyse_conceptuelle_par_réification_de_la_classe_association>>.

On retrouvera donc les classes du domaine métier dans le dossier `domain`.

Pour la représentation JSON, on se référera au fichier `json/BoxJson.kt` qui définit
les classes `AlimentBoxJson` et `BoxJson` et la fonction `fromBoxToBoxJson`.

== Initialisation de la base de données

On se réfère à la classe `DatabaseInitializer`, qui hérite de `ApplicationRunner` et sa méthode `run` lancée automatiquement au démarrage de l'application.

L'algorithme est un ETL qui prend en entrée un fichier JSON décrivant des boxes sushi et injecte les données dans une base de données relationnelle.

C'est la fonction inverse de l'API !

[source, kotlin]
----

for (boxJson in boxesJsonList) {
    var box : Box = Box()
    box.nom = boxJson.nom
    box.prix = boxJson.prix
    box.image = boxJson.image
    box.prix = boxJson.prix
    box.nbPieces = boxJson.pieces

    for (saveur in boxJson.saveurs) {
        var s: Saveur = saveurRepository.checkSaveSaveur(saveur)
        box.saveurs.add(s)
    }

    // save a new box
    boxRepository.save(box)

    for (alimentj in boxJson.aliments ) {
        // first create/save aliment if not exists
        val aliment = alimentRepository.checkSaveAliment(alimentj.nom)
        // create/save alimentBox
        alimentBoxRepository.save(AlimentBox(box, aliment, alimentj.quantite))
    }
}
----

